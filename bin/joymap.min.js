/* @flow */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("joymap", [], factory);
	else if(typeof exports === 'object')
		exports["joymap"] = factory();
	else
		root["joymap"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.l = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };

/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};

/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};

/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.stickBindings = exports.stickIndexMapping = exports.buttonBindings = exports.buttonIndexMapping = undefined;
exports.makeButtonBinding = makeButtonBinding;
exports.addButtonAlias = addButtonAlias;
exports.makeStickBinding = makeStickBinding;
exports.addStickAlias = addStickAlias;
exports.getRawGamepads = getRawGamepads;
exports.updateListenOptions = updateListenOptions;
exports.nameIsValid = nameIsValid;

var _tools = __webpack_require__(1);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/* @flow */
/*:: import type {
    IStickAlias, IButtonAlias,
    IStickBinding, IButtonBinding,
    IParsedGamepad, IListenOptions
} from '../types';*/
var buttonIndexMapping = exports.buttonIndexMapping = {
    dpadUp: 12,
    dpadDown: 13,
    dpadLeft: 14,
    dpadRight: 15,
    L1: 4,
    L2: 6,
    L3: 10,
    R1: 5,
    R2: 7,
    R3: 11,
    A: 0,
    B: 1,
    X: 2,
    Y: 3,
    start: 9,
    select: 8
};

var mockButtons = {
    home: {
        index: -1,
        mapper: function mapper() {
            return 0;
        }
    }
};

function makeButtonBinding(index /*: number*/) /*: IButtonBinding*/ {
    return {
        index: index,
        mapper: function mapper(pad) {
            return pad.buttons[index];
        }
    };
}

var buttonBindings /*: { [key: string]: IButtonBinding }*/ = exports.buttonBindings = Object.assign((0, _tools.mapValues)(function (value) {
    return makeButtonBinding(value);
}, buttonIndexMapping), mockButtons);

function addButtonAlias(alias /*: ?IButtonAlias*/, inputs /*: string[]*/) {
    if (!alias) {
        return {
            inputs: inputs,
            value: 0,
            pressed: false,
            justChanged: false
        };
    }

    return Object.assign({}, alias, {
        inputs: [].concat(_toConsumableArray(alias.inputs), _toConsumableArray(inputs))
    });
}

var stickIndexMapping = exports.stickIndexMapping = {
    L: [0, 1],
    R: [2, 3]
};

function makeStickBinding() /*: IStickBinding*/ {
    for (var _len = arguments.length, indexes = Array(_len), _key = 0; _key < _len; _key++) {
        indexes[_key] = arguments[_key];
    }

    return {
        indexes: indexes,
        mapper: function mapper(pad, inverts) {
            return indexes.map(function (value, i) {
                return !inverts[i] ? pad.axes[value] : pad.axes[value] * -1;
            });
        }
    };
}
var stickBindings /*: { [key: string]: IStickBinding }*/ = exports.stickBindings = (0, _tools.mapValues)(function (values) {
    return makeStickBinding.apply(undefined, _toConsumableArray(values));
}, stickIndexMapping);

function addStickAlias(alias /*: ?IStickAlias*/, inputs /*: string[]*/) {
    if (!alias) {
        return {
            inputs: inputs,
            value: [0, 0],
            pressed: false,
            justChanged: false
        };
    }

    return Object.assign({}, alias, {
        inputs: [].concat(_toConsumableArray(alias.inputs), _toConsumableArray(inputs))
    });
}

function getRawGamepads() /*: Gamepad[]*/ {
    if (navigator && navigator.getGamepads) {
        return Array.from(navigator.getGamepads());
    }
    return [];
}

function updateListenOptions(listenOptions /*: IListenOptions | null*/, parsedGamepad /*: IParsedGamepad*/, threshold /*: number*/) {
    if (!listenOptions) {
        return null;
    }

    var callback = listenOptions.callback,
        quantity = listenOptions.quantity,
        type = listenOptions.type,
        currentValue = listenOptions.currentValue,
        targetValue = listenOptions.targetValue,
        useTimeStamp = listenOptions.useTimeStamp,
        consecutive = listenOptions.consecutive,
        allowOffset = listenOptions.allowOffset;


    var indexes = type === 'axes' ? (0, _tools.findIndexes)(function (value) {
        return Math.abs(value) > threshold;
    }, parsedGamepad.axes) : (0, _tools.findIndexes)(function (_ref) {
        var pressed = _ref.pressed,
            justChanged = _ref.justChanged;
        return pressed && (currentValue !== 0 || justChanged);
    }, parsedGamepad.buttons);

    if (indexes.length === quantity && (!consecutive || (0, _tools.isConsecutive)(indexes)) && (allowOffset || indexes[0] % quantity === 0)) {
        if (useTimeStamp && currentValue === 0) {
            return Object.assign({}, listenOptions, { currentValue: Date.now() });
        }

        var comparison = useTimeStamp ? Date.now() - currentValue : currentValue + 1;

        if (targetValue <= comparison) {
            callback.apply(undefined, _toConsumableArray(indexes));
            return null;
        }

        if (!useTimeStamp) {
            return Object.assign({}, listenOptions, { currentValue: comparison });
        }

        return listenOptions;
    }

    // Clean currentValue
    return Object.assign({}, listenOptions, { currentValue: 0 });
}

function nameIsValid(name /*: string*/) {
    return (/^[a-z0-9]+$/i.test(name)
    );
}

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.noop = noop;
exports.map = map;
exports.isFunction = isFunction;
exports.includes = includes;
exports.difference = difference;
exports.omit = omit;
exports.unique = unique;
exports.isConsecutive = isConsecutive;
exports.findIndexes = findIndexes;
exports.mapValues = mapValues;
exports.matches = matches;
exports.find = find;
exports.findIndex = findIndex;
exports.findKey = findKey;
/* @flow */

// Lodash function replacements

function noop() {}

function map() /*: any[]*/ {
    var attr /*: string*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var target /*: Object[] | Object*/ = arguments[1];

    if (Array.isArray(target)) {
        return target.map(function (value) {
            return value[attr];
        });
    }

    var indexes = Object.keys(target);
    var length = indexes.length;
    var result = [];
    var i = 0;
    while (i < length) {
        var _index = indexes[i];
        result.push(target[_index][attr]);
        i += 1;
    }

    return result;
}

function isFunction(value /*: any*/) /*: boolean*/ {
    return typeof value === 'function';
}

function includes /*:: <T>*/(search /*: T*/) /*: boolean*/ {
    var list /*: T[]*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    return list.indexOf(search) !== -1;
}

function difference /*:: <T>*/(source /*: T[]*/, removal /*: T[]*/) /*: T[]*/ {
    var length = source.length;
    var result = [];
    var i = 0;

    while (i < length) {
        if (!includes(source[i], removal)) {
            result.push(source[i]);
        }
        i += 1;
    }

    return result;
}

function omit(indexes /*: string[]*/, target /*: Object*/) /*: Object*/ {
    var length = indexes.length;
    var result = Object.assign({}, target);
    var i = 0;

    while (i < length) {
        delete result[indexes[i]];
        i += 1;
    }

    return result;
}

function unique /*:: <T>*/(target /*: T[]*/) /*: T[]*/ {
    var length = target.length;

    if (length <= 1) {
        return target;
    }

    var result = [];
    var i = 0;
    while (i < length) {
        if (!result.includes(target[i])) {
            result.push(target[i]);
        }
        i += 1;
    }

    return result;
}

function isConsecutive(target /*: number[]*/) /*: boolean*/ {
    var length = target.length;

    if (length <= 1) {
        return true;
    }

    var i = 0;
    while (i < length - 1) {
        if (target[i] + 1 !== target[i + 1]) {
            return false;
        }
        i += 1;
    }

    return true;
}

/*:: type FindIndexesCb = (value: any, index: number) => boolean;*/
function findIndexes(iterator /*: FindIndexesCb*/, target /*: any[]*/) /*: number[]*/ {
    var length = target.length;
    var result = [];
    var i = 0;

    while (i < length) {
        if (iterator(target[i], i)) {
            result.push(i);
        }
        i += 1;
    }

    return result;
}

/*:: type MapValuesCb = (value: any, name: string) => any;*/
function mapValues(iterator /*: MapValuesCb*/, obj /*: Object*/) /*: Object*/ {
    var result = {};
    Object.keys(obj).forEach(function (name) {
        result[name] = iterator(obj[name], name);
    });
    return result;
}

function matches(comparison /*: Object*/, source /*: Object*/) {
    var match = Object.keys(comparison).map(function (name) {
        return [comparison[name], name];
    });
    var length = match.length;
    var i = 0;

    while (i < length) {
        var _match$i = _slicedToArray(match[i], 2),
            _value = _match$i[0],
            _index2 = _match$i[1];

        if (source[_index2] !== _value) {
            return false;
        }
        i += 1;
    }

    return true;
}

function find(search /*: Object*/, target /*: any[]*/) /*: any | null*/ {
    var length = target.length;
    var i = 0;

    while (i < length) {
        var _value2 = target[i];
        if (matches(search, _value2)) {
            return _value2;
        }
        i += 1;
    }

    return null;
}

function findIndex(search /*: Object*/, target /*: any[]*/) /*: number*/ {
    var length = target.length;
    var i = 0;

    while (i < length) {
        if (matches(search, target[i])) {
            return i;
        }
        i += 1;
    }

    return -1;
}

/*:: type FindKeyCb = (value: any, name?: string) => boolean;*/
function findKey(search /*: FindKeyCb | Object*/, target /*: Object*/) /*: string | null*/ {
    var targetIndexes = Object.keys(target);
    var length = targetIndexes.length;
    var i = 0;
    if (typeof search === 'function') {
        while (i < length) {
            var _index3 = targetIndexes[i];
            if (search(target[_index3], _index3)) {
                return _index3;
            }
            i += 1;
        }
    } else {
        while (i < length) {
            var _index4 = targetIndexes[i];
            if (matches(search, target[_index4])) {
                return _index4;
            }
            i += 1;
        }
    }

    return null;
}

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = createJoyMap;

var _utils = __webpack_require__(0);

var _tools = __webpack_require__(1);

var _Player = __webpack_require__(3);

var _Player2 = _interopRequireDefault(_Player);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*:: import type { IPlayer } from './Player';*/ /* @flow */

/*:: export type IJoyMap = {
    isSupported: boolean,

    gamepads: Gamepad[],
    players: { [key: string]: IPlayer },

    start: () => void,
    stop: () => void,
    getUnusedGamepadIds: () => string[],
    setPlayers: (jsonString: string) => void,
    addPlayer: (name: string) => IPlayer,
    removePlayer: (player: IPlayer) => void,
    cleanPlayers: () => void,
    poll: () => void
};*/
/*:: type IParams = {
    threshold: number,
    clampThreshold: boolean,
    onPoll: () => void,
    playerHandling: 'manual' | 'auto'
};*/
function createJoyMap() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$threshold = _ref.threshold,
        threshold = _ref$threshold === undefined ? 0.2 : _ref$threshold,
        _ref$clampThreshold = _ref.clampThreshold,
        clampThreshold = _ref$clampThreshold === undefined ? true : _ref$clampThreshold,
        _ref$onPoll = _ref.onPoll,
        onPoll = _ref$onPoll === undefined ? _tools.noop : _ref$onPoll,
        _ref$playerHandling = _ref.playerHandling,
        playerHandling = _ref$playerHandling === undefined ? 'auto' : _ref$playerHandling;

    var isSupported = navigator && (0, _tools.isFunction)(navigator.getGamepads);
    var animationFrameRequestId /*: number | null*/ = null;

    var joyMap /*: IJoyMap*/ = {
        isSupported: isSupported,
        gamepads: [],
        players: {},

        start: function start() {
            if (isSupported && animationFrameRequestId === null) {
                (function () {
                    var step = function step() {
                        joyMap.poll();
                        animationFrameRequestId = window.requestAnimationFrame(step);
                    };
                    animationFrameRequestId = window.requestAnimationFrame(step);
                })();
            }
        },
        stop: function stop() {
            if (animationFrameRequestId !== null) {
                window.cancelAnimationFrame(animationFrameRequestId);
                animationFrameRequestId = null;
            }
        },
        getUnusedGamepadIds: function getUnusedGamepadIds() /*: string[]*/ {
            return (0, _tools.difference)((0, _tools.map)('id', joyMap.gamepads), (0, _tools.map)('gamepadId', joyMap.players));
        },
        setPlayers: function setPlayers() {
            var jsonString /*: string*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '{}';

            joyMap.cleanPlayers();
            joyMap.players = JSON.parse(jsonString);
        },
        addPlayer: function addPlayer(name /*: string*/) /*: IPlayer*/ {
            if (!(0, _utils.nameIsValid)(name)) {
                throw new Error('On addPlayer(\'' + name + '\'): argument contains invalid characters');
            }

            var player /*: IPlayer*/ = (0, _Player2.default)({ name: name, threshold: threshold, clampThreshold: clampThreshold });

            var gamepadIds /*: string[]*/ = (0, _tools.map)('id', joyMap.gamepads);
            var unusedId /*: ?string*/ = gamepadIds.find(function (gamepadId /*: string*/) {
                return !(0, _tools.findKey)({ gamepadId: gamepadId }, joyMap.players);
            });

            if (unusedId) {
                player.connect(unusedId);
            }

            joyMap.players[name] = player;

            return player;
        },
        removePlayer: function removePlayer(player /*: IPlayer*/) {
            joyMap.players = (0, _tools.omit)([player.name], joyMap.players);
            player.destroy();
        },
        cleanPlayers: function cleanPlayers() {
            // REVIEW: Had to use "any" type because flow thinks Object.values return mixed
            // and fails to notice that joyMap.players is { [key: string]: IPlayer }
            Object.values(joyMap.players).forEach(function (player /*: any*/) {
                return joyMap.removePlayer(player);
            });
        },
        poll: function poll() {
            joyMap.gamepads = (0, _utils.getRawGamepads)().filter(function (rawGamepad /*: ?Gamepad*/) {
                return rawGamepad && rawGamepad.connected && rawGamepad.buttons.length && rawGamepad.axes.length && (!!rawGamepad.id || rawGamepad.id === 0);
            });

            Object.keys(joyMap.players).forEach(function (name /*: string*/) {
                var player /*: IPlayer*/ = joyMap.players[name];
                var unusedGamepadIds = joyMap.getUnusedGamepadIds();

                // Given unassigned players and unusued gamepads, automatically assign them
                if (playerHandling === 'auto' && player.gamepadId === null && unusedGamepadIds.length > 0) {
                    player.connect(unusedGamepadIds[0]);
                }

                var gamepad /*: ?Gamepad*/ = (0, _tools.find)({ id: player.gamepadId }, joyMap.gamepads);

                if (!player.connected) {
                    if (gamepad) {
                        player.reconnect();
                        player.update(gamepad);
                    }
                } else if (gamepad) {
                    player.update(gamepad);
                } else {
                    player.disconnect();
                }
            });

            onPoll();
        }
    };

    return joyMap;
}

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* @flow */


exports.default = createPlayer;

var _utils = __webpack_require__(0);

var _tools = __webpack_require__(1);

/*:: import type {
    IStickValue, IButtonValue, IParsedGamepad, IStick, IButton,
    IStickAlias, IButtonAlias, IAggregator,
    IStickBinding, IButtonBinding, IListenOptions, IListenParams
} from './types';*/
/*:: export type IPlayer = {
    name: string,
    parsedGamepad: IParsedGamepad,

    sticks: { [key: string]: IStick },
    buttons: { [key: string]: IButton },
    buttonBindings: { [key: string]: IButtonBinding },
    stickBindings: { [key: string]: IStickBinding },

    gamepadId: ?string,
    connected: boolean,
    buttonAliases: { [key: string]: IButtonAlias },
    stickAliases: { [key: string]: IStickAlias },
    aggregators: { [key: string]: IAggregator },

    cleanBindings: () => void,
    disconnect: () => void,
    reconnect: () => void,
    connect: (gamepadId: string) => void,
    clearButtonBindings: () => void,
    clearStickBindings: () => void,

    buttonRebind: (inputName: string, binding: IButtonBinding) => void,
    stickRebind: (inputName: string, binding: IStickBinding) => void,
    cancelListen: () => void,
    listenButton: (callback: Function, quantity?: number, params?: IListenParams) => void,
    listenAxis: (callback: Function, quantity?: number, params?: IListenParams) => void,
    buttonRebindOnPress: (inputName: string, callback: Function, allowDuplication: boolean) => void,
    stickRebindOnPress: (inputName: string, callback: Function, allowDuplication: boolean) => void,
    setAggregator: (aggregatorName: string, callback: Function) => void,
    removeAggregator: (aggregatorName: string) => void,
    cleanAggregators: () => void,
    setAlias: (aliasName: string, inputs: string | string[]) => void,
    removeAlias: (aliasName: string) => void,
    cleanAliases: () => void,
    destroy: () => void,
    parseGamepad: (gamepad: Gamepad) => IParsedGamepad,
    update: (gamepad: Gamepad) => void,
    getButtonValue: (value: IButtonValue) => IButtonValue,
    isButtonSignificant: (value: IButtonValue) => boolean,
    updateButtons: (gamepad: IParsedGamepad) => void,
    getStickValue: (stickValues: IStickValue) => IStickValue,
    isStickSignificant: (stickValues: IStickValue) => boolean,
    updateStick: (gamepad: IParsedGamepad) => void,
    updateAliases: () => void,
    updateAggregators: (gamepad: Gamepad) => void
};*/


function _cleanBindings() {
    return {
        buttonBindings: _utils.buttonBindings,
        stickBindings: _utils.stickBindings,
        buttons: (0, _tools.mapValues)(function () {
            return {
                value: 0,
                pressed: false,
                justChanged: false
            };
        }, _utils.buttonBindings),
        sticks: (0, _tools.mapValues)(function () {
            return {
                value: [0, 0],
                pressed: false,
                justChanged: false,
                inverts: [false, false]
            };
        }, _utils.stickBindings)
    };
}

function createPlayer() /*: IPlayer*/ {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        name = _ref.name,
        _ref$threshold = _ref.threshold,
        threshold = _ref$threshold === undefined ? 0.3 : _ref$threshold,
        _ref$clampThreshold = _ref.clampThreshold,
        clampThreshold = _ref$clampThreshold === undefined ? true : _ref$clampThreshold;

    var listenOptions /*: null | IListenOptions*/ = null;

    var player /*: IPlayer*/ = _extends({
        name: name,
        parsedGamepad: {
            buttons: [],
            axes: []
        },
        buttonAliases: {},
        stickAliases: {},
        aggregators: {},
        gamepadId: null,
        connected: false
    }, _cleanBindings(), {
        cleanBindings: function cleanBindings() {
            Object.assign(player, _cleanBindings());
        },
        disconnect: function disconnect() {
            player.connected = false;
        },
        reconnect: function reconnect() {
            player.connected = true;
        },
        connect: function connect(gamepadId /*: string*/) {
            player.connected = true;
            player.gamepadId = gamepadId;
        },
        clearButtonBindings: function clearButtonBindings() {
            player.buttonBindings = {};
        },
        clearStickBindings: function clearStickBindings() {
            player.stickBindings = {};
        },
        buttonRebind: function buttonRebind(inputName /*: string*/, binding /*: IButtonBinding*/) {
            if (!(0, _utils.nameIsValid)(inputName)) {
                throw new Error('On buttonRebind(\'' + inputName + '\'): argument contains invalid characters');
            }
            player.buttonBindings[inputName] = binding;
        },
        stickRebind: function stickRebind(inputName /*: string*/, binding /*: IStickBinding*/) {
            if (!(0, _utils.nameIsValid)(inputName)) {
                throw new Error('On stickRebind(\'' + inputName + '\'): argument contains invalid characters');
            }
            player.stickBindings[inputName] = binding;
        },
        cancelListen: function cancelListen() {
            listenOptions = null;
        },
        listenButton: function listenButton(callback /*: (...indexes: number[]) => void*/) {
            var quantity /*:: ?: number*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

            var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
                _ref2$waitFor = _ref2.waitFor,
                waitFor = _ref2$waitFor === undefined ? [1, 'polls'] : _ref2$waitFor,
                _ref2$consecutive = _ref2.consecutive,
                consecutive = _ref2$consecutive === undefined ? false : _ref2$consecutive,
                _ref2$allowOffset = _ref2.allowOffset,
                allowOffset = _ref2$allowOffset === undefined ? true : _ref2$allowOffset;

            listenOptions = {
                callback: callback,
                quantity: quantity,
                type: 'buttons',
                currentValue: 0,
                useTimeStamp: waitFor[1] === 'ms',
                targetValue: waitFor[0],
                consecutive: consecutive,
                allowOffset: allowOffset
            };
        },
        listenAxis: function listenAxis(callback /*: (...indexes: number[]) => void*/) {
            var quantity /*: number*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;

            var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
                _ref3$waitFor = _ref3.waitFor,
                waitFor = _ref3$waitFor === undefined ? [100, 'ms'] : _ref3$waitFor,
                _ref3$consecutive = _ref3.consecutive,
                consecutive = _ref3$consecutive === undefined ? true : _ref3$consecutive,
                _ref3$allowOffset = _ref3.allowOffset,
                allowOffset = _ref3$allowOffset === undefined ? true : _ref3$allowOffset;

            listenOptions = {
                callback: callback,
                quantity: quantity,
                type: 'axes',
                currentValue: 0,
                useTimeStamp: waitFor[1] === 'ms',
                targetValue: waitFor[0],
                consecutive: consecutive,
                allowOffset: allowOffset
            };
        },
        buttonRebindOnPress: function buttonRebindOnPress(inputName /*: string*/) {
            var callback /*: () => void*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _tools.noop;
            var allowDuplication /*: boolean*/ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

            if (!(0, _utils.nameIsValid)(inputName)) {
                throw new Error('On buttonRebindOnPress(\'' + inputName + '\', ...):\n                first argument contains invalid characters');
            }
            player.listenButton(function (index) {
                var bindingIndex = (0, _tools.findKey)({ index: index }, player.buttonBindings);

                if (bindingIndex) {
                    if (inputName !== bindingIndex) {
                        if (allowDuplication) {
                            player.buttonBindings[inputName] = (0, _utils.makeButtonBinding)(index);
                        } else {
                            var _binding = player.buttonBindings[bindingIndex];
                            player.buttonBindings[bindingIndex] = player.buttonBindings[inputName];
                            player.buttonBindings[inputName] = _binding;
                        }
                    }
                } else {
                    player.buttonBindings[inputName] = (0, _utils.makeButtonBinding)(index);
                }

                callback(bindingIndex);
            });
        },
        stickRebindOnPress: function stickRebindOnPress(inputName /*: string*/) {
            var callback /*: () => void*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _tools.noop;
            var allowDuplication /*: boolean*/ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

            if (!(0, _utils.nameIsValid)(inputName)) {
                throw new Error('On stickRebindOnPress(\'' + inputName + '\', ...):\n                first argument contains invalid characters');
            }

            player.listenAxis(function (index1, index2) {
                // REVIEW Needed to define the callback as a function
                var findCallback /*: Function*/ = function findCallback(_ref4) {
                    var indexes = _ref4.indexes;
                    return indexes.includes(index1) && indexes.includes(index2);
                };

                var bindingIndex /*: string | null*/ = (0, _tools.findKey)(findCallback, player.stickBindings);

                if (bindingIndex) {
                    if (inputName !== bindingIndex) {
                        if (allowDuplication) {
                            player.stickBindings[inputName] = (0, _utils.makeStickBinding)(index1, index2);
                        } else {
                            var _binding2 = player.stickBindings[bindingIndex];
                            player.stickBindings[bindingIndex] = player.stickBindings[inputName];
                            player.stickBindings[inputName] = _binding2;
                        }
                    }
                } else {
                    player.stickBindings[inputName] = (0, _utils.makeStickBinding)(index1, index2);
                }

                callback(bindingIndex);
            });
        },
        setAggregator: function setAggregator(aggregatorName /*: string*/, callback /*: Function*/) {
            if (!(0, _utils.nameIsValid)(aggregatorName)) {
                throw new Error('On setAggregator(\'' + aggregatorName + '\', ...):\n                first argument contains invalid characters');
            }
            player.aggregators[aggregatorName] = { callback: callback, value: null };
        },
        removeAggregator: function removeAggregator(aggregatorName /*: string*/) {
            player.aggregators = (0, _tools.omit)([aggregatorName], player.aggregators);
        },
        cleanAggregators: function cleanAggregators() {
            player.aggregators = {};
        },
        setAlias: function setAlias(aliasName /*: string*/, inputs /*: string | string[]*/) {
            if (!(0, _utils.nameIsValid)(aliasName)) {
                throw new Error('On setAlias(\'' + aliasName + '\', ...): first argument contains invalid characters');
            }
            var inputList /*: string[]*/ = typeof inputs === 'string' ? [inputs] : inputs;

            if ((0, _tools.difference)(inputList, Object.keys(player.buttons)).length === 0) {
                player.buttonAliases[aliasName] = (0, _utils.addButtonAlias)(player.buttonAliases[aliasName], inputList);
            } else if ((0, _tools.difference)(inputList, Object.keys(player.sticks)).length === 0) {
                var lengths /*: number[]*/ = inputList.map(function (inputName) {
                    return player.sticks[inputName].value.length;
                });

                if ((0, _tools.unique)(lengths).length === 1) {
                    player.stickAliases[aliasName] = (0, _utils.addStickAlias)(player.stickAliases[aliasName], inputList);
                } else {
                    throw new Error('On setAlias(' + aliasName + ', [' + inputList.join(', ') + ']):\n                        all sticks specified did not have the same number of axes');
                }
            } else {
                throw new Error('On setAlias(' + aliasName + ', [' + inputList.join(', ') + ']):\n                    either one of the inputs is void or it wasn\'t all a collection of just buttons or just sticks');
            }
        },
        removeAlias: function removeAlias(aliasName /*: string*/) {
            if ((0, _tools.includes)(aliasName, Object.keys(player.buttonAliases))) {
                player.buttonAliases = (0, _tools.omit)([aliasName], player.buttonAliases);
            } else if ((0, _tools.includes)(aliasName, Object.keys(player.stickAliases))) {
                player.stickAliases = (0, _tools.omit)([aliasName], player.stickAliases);
            } else {
                throw new Error('On removeAlias(\'' + aliasName + '\'): Specified alias does not exist');
            }
        },
        cleanAliases: function cleanAliases() {
            player.buttonAliases = {};
            player.stickAliases = {};
        },
        destroy: function destroy() {
            player.disconnect();
            player.cleanBindings();
            player.cleanAliases();
            player.cleanAggregators();
        },
        parseGamepad: function parseGamepad(gamepad /*: Gamepad*/) /*: IParsedGamepad*/ {
            var prevGamepad = player.parsedGamepad;

            return {
                buttons: gamepad.buttons.map(function (_ref5, index /*: number*/) {
                    var value = _ref5.value;

                    var previous /*: IButton*/ = prevGamepad.buttons[index];
                    var pressed = player.isButtonSignificant(value);

                    return {
                        pressed: pressed,
                        justChanged: pressed !== (previous ? player.isButtonSignificant(previous.value) : false),
                        value: value
                    };
                }),
                axes: gamepad.axes
            };
        },
        update: function update(gamepad /*: Gamepad*/) {
            player.parsedGamepad = player.parseGamepad(gamepad);
            player.updateButtons(player.parsedGamepad);
            player.updateStick(player.parsedGamepad);
            player.updateAliases();
            player.updateAggregators(gamepad); // REVIEW: Shouldn't this use parsedGamepad too?

            listenOptions = (0, _utils.updateListenOptions)(listenOptions, player.parsedGamepad, threshold);
        },
        getButtonValue: function getButtonValue() /*: IButtonValue*/ {
            var value /*: IButtonValue*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

            if (!clampThreshold) {
                return value;
            }

            return !player.isButtonSignificant(value) ? 0 : value;
        },
        isButtonSignificant: function isButtonSignificant() /*: boolean*/ {
            var value /*: IButtonValue*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

            return Math.abs(value) > threshold;
        },
        updateButtons: function updateButtons(gamepad /*: IParsedGamepad*/) {
            player.buttons = (0, _tools.mapValues)(function (binding /*: IButtonBinding*/) {
                return binding.mapper(gamepad);
            }, player.buttonBindings);
        },
        getStickValue: function getStickValue(stickValues /*: IStickValue*/) /*: IStickValue*/ {
            if (clampThreshold && !player.isStickSignificant(stickValues)) {
                return stickValues.map(function () {
                    return 0;
                });
            }

            return stickValues;
        },
        isStickSignificant: function isStickSignificant(stickValues /*: IStickValue*/) /*: boolean*/ {
            return stickValues.findIndex(function (value) {
                return Math.abs(value) >= threshold;
            }) !== -1;
        },
        updateStick: function updateStick(gamepad /*: IParsedGamepad*/) {
            var prevStick = player.sticks;

            player.sticks = (0, _tools.mapValues)(function (binding /*: IStickBinding*/, inputName /*: string*/) {
                var previous /*: IStick*/ = prevStick[inputName];
                var value /*: IStickValue*/ = binding.mapper(gamepad, previous.inverts);
                var pressed = player.isStickSignificant(value);

                return {
                    pressed: pressed,
                    justChanged: pressed !== player.isStickSignificant(previous.value),
                    value: player.getStickValue(value),
                    inverts: previous.inverts
                };
            }, player.stickBindings);
        },
        updateAliases: function updateAliases() {
            // When an alias has more than 1 button assigned to it, use for reference the one that's pressed the most
            player.buttonAliases = (0, _tools.mapValues)(function (alias /*: IButtonAlias*/) {
                var value = 0;

                alias.inputs.forEach(function (aliasName) {
                    if (player.buttons[aliasName].value > value) {
                        value = player.buttons[aliasName].value;
                    }
                });

                value = player.getButtonValue(value);
                var pressed = player.isButtonSignificant(value);

                return {
                    pressed: pressed,
                    justChanged: pressed !== player.isButtonSignificant(alias.value),
                    value: value,
                    inputs: alias.inputs
                };
            }, player.buttonAliases);

            // When an alias has more than 1 stick assigned to it, do an average
            player.stickAliases = (0, _tools.mapValues)(function (alias /*: IStickAlias*/) {
                var counts = [];
                var count = 0;

                alias.inputs.forEach(function (aliasName) {
                    if (player.sticks[aliasName].pressed) {
                        counts = player.sticks[aliasName].value.map(function (v, i) {
                            return v + (counts[i] || 0);
                        });
                        count += 1;
                    }
                });

                var value = count === 0 ? player.sticks[alias.inputs[0]].value.map(function () {
                    return 0;
                }) : counts.map(function (v) {
                    return v / count;
                });
                var pressed = player.isStickSignificant(value);

                return {
                    pressed: pressed,
                    justChanged: pressed !== player.isStickSignificant(alias.value),
                    value: value,
                    inputs: alias.inputs
                };
            }, player.stickAliases);
        },
        updateAggregators: function updateAggregators(gamepad /*: Gamepad*/) {
            var _this = this;

            player.aggregators = (0, _tools.mapValues)(function (_ref6) {
                var callback = _ref6.callback,
                    value = _ref6.value;
                return {
                    callback: callback,
                    value: callback(_this, value, gamepad)
                };
            }, player.aggregators);
        }
    });

    return player;
}

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stickBindings = exports.makeButtonBinding = undefined;

var _JoyMap = __webpack_require__(2);

var _JoyMap2 = _interopRequireDefault(_JoyMap);

var _utils = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* @flow */

// Ugly imports and export because flow does not understand export X from 'path'

exports.default = _JoyMap2.default;
var makeButtonBinding = exports.makeButtonBinding = _utils.makeButtonBinding;
var stickBindings = exports.stickBindings = _utils.stickBindings;

/***/ }
/******/ ]);
});