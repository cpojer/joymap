/* @flow */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("joymap", [], factory);
	else if(typeof exports === 'object')
		exports["joymap"] = factory();
	else
		root["joymap"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.l = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };

/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};

/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};

/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.stickBindings = exports.stickIndexMapping = exports.buttonBindings = exports.buttonIndexMapping = undefined;
exports.makeButtonBinding = makeButtonBinding;
exports.addButtonAlias = addButtonAlias;
exports.makeStickBinding = makeStickBinding;
exports.addStickAlias = addStickAlias;
exports.getRawGamepads = getRawGamepads;
exports.updateListenOptions = updateListenOptions;

var _tools = __webpack_require__(1);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/* @flow */
/*:: import type {
    IStickAlias, IButtonAlias,
    IStickBinding, IButtonBinding,
    IParsedGamepad, IListenOptions
} from '../types';*/
var buttonIndexMapping = exports.buttonIndexMapping = {
    dpadUp: 12,
    dpadDown: 13,
    dpadLeft: 14,
    dpadRight: 15,
    L1: 4,
    L2: 6,
    L3: 10,
    R1: 5,
    R2: 7,
    R3: 11,
    A: 0,
    B: 1,
    X: 2,
    Y: 3,
    start: 9,
    select: 8
};

var mockButtons = {
    home: {
        index: -1,
        mapper: function mapper() {
            return 0;
        }
    }
};

function makeButtonBinding(index /*: number*/) /*: IButtonBinding*/ {
    return {
        index: index,
        mapper: function mapper(pad) {
            return pad.buttons[index];
        }
    };
}

var buttonBindings /*: { [key: string]: IButtonBinding }*/ = exports.buttonBindings = Object.assign((0, _tools.mapValues)(function (value) {
    return makeButtonBinding(value);
}, buttonIndexMapping), mockButtons);

function addButtonAlias(alias /*: ?IButtonAlias*/, inputs /*: string[]*/) {
    if (!alias) {
        return {
            inputs: inputs,
            value: 0,
            pressed: false,
            justChanged: false
        };
    }

    return Object.assign({}, alias, {
        inputs: [].concat(_toConsumableArray(alias.inputs), _toConsumableArray(inputs))
    });
}

var stickIndexMapping = exports.stickIndexMapping = {
    L: [0, 1],
    R: [2, 3]
};

function makeStickBinding() /*: IStickBinding*/ {
    for (var _len = arguments.length, indexes = Array(_len), _key = 0; _key < _len; _key++) {
        indexes[_key] = arguments[_key];
    }

    return {
        indexes: indexes,
        mapper: function mapper(pad, inverts) {
            return indexes.map(function (value, i) {
                return !inverts[i] ? pad.axes[value] : pad.axes[value] * -1;
            });
        }
    };
}
var stickBindings /*: { [key: string]: IStickBinding }*/ = exports.stickBindings = (0, _tools.mapValues)(function (values) {
    return makeStickBinding.apply(undefined, _toConsumableArray(values));
}, stickIndexMapping);

function addStickAlias(alias /*: ?IStickAlias*/, inputs /*: string[]*/) {
    if (!alias) {
        return {
            inputs: inputs,
            value: [0, 0],
            pressed: false,
            justChanged: false
        };
    }

    return Object.assign({}, alias, {
        inputs: [].concat(_toConsumableArray(alias.inputs), _toConsumableArray(inputs))
    });
}

function getRawGamepads() /*: Gamepad[]*/ {
    if (navigator && navigator.getGamepads) {
        return Array.from(navigator.getGamepads());
    }
    return [];
}

function updateListenOptions(listenOptions /*: IListenOptions | null*/, parsedGamepad /*: IParsedGamepad*/, threshold /*: number*/) {
    if (!listenOptions) {
        return null;
    }

    var callback = listenOptions.callback,
        quantity = listenOptions.quantity,
        type = listenOptions.type,
        currentValue = listenOptions.currentValue,
        targetValue = listenOptions.targetValue,
        useTimeStamp = listenOptions.useTimeStamp,
        consecutive = listenOptions.consecutive,
        allowOffset = listenOptions.allowOffset;


    var indexes = type === 'axes' ? (0, _tools.findIndexes)(function (value) {
        return Math.abs(value) > threshold;
    }, parsedGamepad.axes) : (0, _tools.findIndexes)(function (_ref) {
        var pressed = _ref.pressed,
            justChanged = _ref.justChanged;
        return pressed && (currentValue !== 0 || justChanged);
    }, parsedGamepad.buttons);

    if (indexes.length === quantity && (!consecutive || (0, _tools.isConsecutive)(indexes)) && (allowOffset || indexes[0] % quantity === 0)) {
        if (useTimeStamp && currentValue === 0) {
            return Object.assign({}, listenOptions, { currentValue: Date.now() });
        }

        var comparison = useTimeStamp ? Date.now() - currentValue : currentValue + 1;

        if (targetValue <= comparison) {
            callback.apply(undefined, _toConsumableArray(indexes));
            return null;
        }

        if (!useTimeStamp) {
            return Object.assign({}, listenOptions, { currentValue: comparison });
        }

        return listenOptions;
    }

    // Clean currentValue
    return Object.assign({}, listenOptions, { currentValue: 0 });
}

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.noop = noop;
exports.map = map;
exports.isFunction = isFunction;
exports.includes = includes;
exports.difference = difference;
exports.omit = omit;
exports.unique = unique;
exports.isConsecutive = isConsecutive;
exports.findIndexes = findIndexes;
exports.mapValues = mapValues;
exports.matches = matches;
exports.find = find;
exports.findIndex = findIndex;
exports.findKey = findKey;
/* @flow */

// Lodash function replacements

function noop() {}

function map() /*: any[]*/ {
    var attr /*: string*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var target /*: Object[] | Object*/ = arguments[1];

    if (Array.isArray(target)) {
        return target.map(function (value) {
            return value[attr];
        });
    }

    var indexes = Object.keys(target);
    var length = indexes.length;
    var result = [];
    var i = 0;
    while (i < length) {
        var _index = indexes[i];
        result.push(target[_index][attr]);
        i += 1;
    }

    return result;
}

function isFunction(value /*: any*/) /*: boolean*/ {
    return typeof value === 'function';
}

function includes /*:: <T>*/(search /*: T*/) /*: boolean*/ {
    var list /*: T[]*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    return list.indexOf(search) !== -1;
}

function difference /*:: <T>*/(source /*: T[]*/, removal /*: T[]*/) /*: T[]*/ {
    var length = source.length;
    var result = [];
    var i = 0;

    while (i < length) {
        if (!includes(source[i], removal)) {
            result.push(source[i]);
        }
        i += 1;
    }

    return result;
}

function omit(indexes /*: string[]*/, target /*: Object*/) /*: Object*/ {
    var length = indexes.length;
    var result = Object.assign({}, target);
    var i = 0;

    while (i < length) {
        delete result[indexes[i]];
        i += 1;
    }

    return result;
}

function unique /*:: <T>*/(target /*: T[]*/) /*: T[]*/ {
    var length = target.length;

    if (length <= 1) {
        return target;
    }

    var result = [];
    var i = 0;
    while (i < length) {
        if (!result.includes(target[i])) {
            result.push(target[i]);
        }
        i += 1;
    }

    return result;
}

function isConsecutive(target /*: number[]*/) /*: boolean*/ {
    var length = target.length;

    if (length <= 1) {
        return true;
    }

    var i = 0;
    while (i < length - 1) {
        if (target[i] + 1 !== target[i + 1]) {
            return false;
        }
        i += 1;
    }

    return true;
}

/*:: type FindIndexesCb = (value: any, index: number) => boolean;*/
function findIndexes(iterator /*: FindIndexesCb*/, target /*: any[]*/) /*: number[]*/ {
    var length = target.length;
    var result = [];
    var i = 0;

    while (i < length) {
        if (iterator(target[i], i)) {
            result.push(i);
        }
        i += 1;
    }

    return result;
}

/*:: type MapValuesCb = (value: any, name: string) => any;*/
function mapValues(iterator /*: MapValuesCb*/, obj /*: Object*/) /*: Object*/ {
    var result = {};
    Object.keys(obj).forEach(function (name) {
        result[name] = iterator(obj[name], name);
    });
    return result;
}

function matches(comparison /*: Object*/, source /*: Object*/) {
    var match = Object.keys(comparison).map(function (name) {
        return [comparison[name], name];
    });
    var length = match.length;
    var i = 0;

    while (i < length) {
        var _match$i = _slicedToArray(match[i], 2),
            _value = _match$i[0],
            _index2 = _match$i[1];

        if (source[_index2] !== _value) {
            return false;
        }
        i += 1;
    }

    return true;
}

function find(search /*: Object*/, target /*: any[]*/) /*: any | null*/ {
    var length = target.length;
    var i = 0;

    while (i < length) {
        var _value2 = target[i];
        if (matches(search, _value2)) {
            return _value2;
        }
        i += 1;
    }

    return null;
}

function findIndex(search /*: Object*/, target /*: any[]*/) /*: number*/ {
    var length = target.length;
    var i = 0;

    while (i < length) {
        if (matches(search, target[i])) {
            return i;
        }
        i += 1;
    }

    return -1;
}

/*:: type FindKeyCb = (value: any, name?: string) => boolean;*/
function findKey(search /*: FindKeyCb | Object*/, target /*: Object*/) /*: string | null*/ {
    var targetIndexes = Object.keys(target);
    var length = targetIndexes.length;
    var i = 0;
    if (typeof search === 'function') {
        while (i < length) {
            var _index3 = targetIndexes[i];
            if (search(target[_index3], _index3)) {
                return _index3;
            }
            i += 1;
        }
    } else {
        while (i < length) {
            var _index4 = targetIndexes[i];
            if (matches(search, target[_index4])) {
                return _index4;
            }
            i += 1;
        }
    }

    return null;
}

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @flow */


var _utils = __webpack_require__(0);

var _tools = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*:: import type {
    IStickValue, IButtonValue, IParsedGamepad, IStick, IButton,
    IStickAlias, IButtonAlias, IAggregator,
    IStickBinding, IButtonBinding, IListenOptions
} from './types';*/
/*:: type IParams = { name: string, threshold: number, clampThreshold: boolean };*/

var Player = function () {
    function Player() {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            name = _ref.name,
            _ref$threshold = _ref.threshold,
            threshold = _ref$threshold === undefined ? 0.3 : _ref$threshold,
            _ref$clampThreshold = _ref.clampThreshold,
            clampThreshold = _ref$clampThreshold === undefined ? true : _ref$clampThreshold;

        _classCallCheck(this, Player);

        this.parsedGamepad = {
            buttons: [],
            axes: []
        };
        this.gamepadId = null;
        this.connected = false;
        this.buttonAliases = {};
        this.stickAliases = {};
        this.aggregators = {};
        this.listenOptions = null;

        this.name = name;
        this.threshold = threshold;
        this.clampThreshold = clampThreshold;

        this.cleanInputs();
    }

    _createClass(Player, [{
        key: 'cleanInputs',
        value: function cleanInputs() {
            this.buttonBindings = _utils.buttonBindings;
            this.stickBindings = _utils.stickBindings;

            this.buttons = (0, _tools.mapValues)(function () {
                return {
                    value: 0,
                    pressed: false,
                    justChanged: false
                };
            }, this.buttonBindings);

            this.sticks = (0, _tools.mapValues)(function () {
                return {
                    value: [0, 0],
                    pressed: false,
                    justChanged: false,
                    inverts: [false, false]
                };
            }, this.stickBindings);
        }
    }, {
        key: 'disconnect',
        value: function disconnect() {
            this.connected = false;
        }
    }, {
        key: 'reconnect',
        value: function reconnect() {
            this.connected = true;
        }
    }, {
        key: 'connect',
        value: function connect(gamepadId /*: string*/) {
            this.connected = true;
            this.gamepadId = gamepadId;
        }
    }, {
        key: 'clearButtonBindings',
        value: function clearButtonBindings() {
            this.buttonBindings = {};
        }
    }, {
        key: 'clearStickBindings',
        value: function clearStickBindings() {
            this.stickBindings = {};
        }
    }, {
        key: 'buttonRebind',
        value: function buttonRebind(inputName /*: string*/, binding /*: IButtonBinding*/) {
            this.buttonBindings[inputName] = binding;
        }
    }, {
        key: 'stickRebind',
        value: function stickRebind(inputName /*: string*/, binding /*: IStickBinding*/) {
            this.stickBindings[inputName] = binding;
        }
    }, {
        key: 'cancelListen',
        value: function cancelListen() {
            this.listenOptions = null;
        }
    }, {
        key: 'listenButton',
        value: function listenButton(callback /*: Function*/) {
            var quantity /*: number*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

            var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
                _ref2$waitFor = _ref2.waitFor,
                waitFor = _ref2$waitFor === undefined ? [1, 'polls'] : _ref2$waitFor,
                _ref2$consecutive = _ref2.consecutive,
                consecutive = _ref2$consecutive === undefined ? false : _ref2$consecutive,
                _ref2$allowOffset = _ref2.allowOffset,
                allowOffset = _ref2$allowOffset === undefined ? true : _ref2$allowOffset;

            this.listenOptions = {
                callback: callback,
                quantity: quantity,
                type: 'buttons',
                currentValue: 0,
                useTimeStamp: waitFor[1] === 'ms',
                targetValue: waitFor[0],
                consecutive: consecutive,
                allowOffset: allowOffset
            };
        }
    }, {
        key: 'listenAxis',
        value: function listenAxis(callback /*: Function*/) {
            var quantity /*: number*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;

            var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
                _ref3$waitFor = _ref3.waitFor,
                waitFor = _ref3$waitFor === undefined ? [100, 'ms'] : _ref3$waitFor,
                _ref3$consecutive = _ref3.consecutive,
                consecutive = _ref3$consecutive === undefined ? true : _ref3$consecutive,
                _ref3$allowOffset = _ref3.allowOffset,
                allowOffset = _ref3$allowOffset === undefined ? true : _ref3$allowOffset;

            this.listenOptions = {
                callback: callback,
                quantity: quantity,
                type: 'axes',
                currentValue: 0,
                useTimeStamp: waitFor[1] === 'ms',
                targetValue: waitFor[0],
                consecutive: consecutive,
                allowOffset: allowOffset
            };
        }
    }, {
        key: 'buttonRebindOnPress',
        value: function buttonRebindOnPress(inputName /*: string*/) {
            var _this = this;

            var callback /*: Function*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _tools.noop;
            var allowDuplication /*: boolean*/ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

            this.listenButton(function (index) {
                var bindingIndex = (0, _tools.findKey)({ index: index }, _this.buttonBindings);

                if (bindingIndex) {
                    if (inputName !== bindingIndex) {
                        if (allowDuplication) {
                            _this.buttonBindings[inputName] = (0, _utils.makeButtonBinding)(index);
                        } else {
                            var binding = _this.buttonBindings[bindingIndex];
                            _this.buttonBindings[bindingIndex] = _this.buttonBindings[inputName];
                            _this.buttonBindings[inputName] = binding;
                        }
                    }
                } else {
                    _this.buttonBindings[inputName] = (0, _utils.makeButtonBinding)(index);
                }

                callback(bindingIndex);
            });
        }
    }, {
        key: 'stickRebindOnPress',
        value: function stickRebindOnPress(inputName /*: string*/) {
            var _this2 = this;

            var callback /*: Function*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _tools.noop;
            var allowDuplication /*: boolean*/ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

            this.listenAxis(function (index1, index2) {
                // REVIEW Needed to define the callback as a function
                var findCallback /*: Function*/ = function findCallback(_ref4) {
                    var indexes = _ref4.indexes;
                    return indexes.includes(index1) && indexes.includes(index2);
                };

                var bindingIndex /*: string | null*/ = (0, _tools.findKey)(findCallback, _this2.stickBindings);

                if (bindingIndex) {
                    if (inputName !== bindingIndex) {
                        if (allowDuplication) {
                            _this2.stickBindings[inputName] = (0, _utils.makeStickBinding)(index1, index2);
                        } else {
                            var binding = _this2.stickBindings[bindingIndex];
                            _this2.stickBindings[bindingIndex] = _this2.stickBindings[inputName];
                            _this2.stickBindings[inputName] = binding;
                        }
                    }
                } else {
                    _this2.stickBindings[inputName] = (0, _utils.makeStickBinding)(index1, index2);
                }

                callback(bindingIndex);
            });
        }
    }, {
        key: 'setAggregator',
        value: function setAggregator(aggregatorName /*: string*/, callback /*: Function*/) {
            this.aggregators[aggregatorName] = { callback: callback, value: null };
        }
    }, {
        key: 'removeAggregator',
        value: function removeAggregator(aggregatorName /*: string*/) {
            this.aggregators = (0, _tools.omit)([aggregatorName], this.aggregators);
        }
    }, {
        key: 'cleanAggregators',
        value: function cleanAggregators() {
            this.aggregators = {};
        }
    }, {
        key: 'setAlias',
        value: function setAlias(aliasName /*: string*/, inputs /*: string | string[]*/) {
            var _this3 = this;

            var inputList /*: string[]*/ = typeof inputs === 'string' ? [inputs] : inputs;

            if ((0, _tools.difference)(inputList, Object.keys(this.buttons)).length === 0) {
                this.buttonAliases[aliasName] = (0, _utils.addButtonAlias)(this.buttonAliases[aliasName], inputList);
            } else if ((0, _tools.difference)(inputList, Object.keys(this.sticks)).length === 0) {
                var lengths /*: number[]*/ = inputList.map(function (name) {
                    return _this3.sticks[name].value.length;
                });

                if ((0, _tools.unique)(lengths).length === 1) {
                    this.stickAliases[aliasName] = (0, _utils.addStickAlias)(this.stickAliases[aliasName], inputList);
                } else {
                    throw new Error('joymap.players.' + this.name + '.setAlias(' + aliasName + '),\n                    all sticks specified did not have the same number of axes');
                }
            } else {
                throw new Error('joymap.players.' + this.name + '.setAlias(' + aliasName + '),\n                either on of the inputs is void or it wasn\'t all a collection of just buttons or just sticks');
            }
        }
    }, {
        key: 'removeAlias',
        value: function removeAlias(aliasName /*: string*/) {
            if ((0, _tools.includes)(aliasName, Object.keys(this.buttonAliases))) {
                this.buttonAliases = (0, _tools.omit)([aliasName], this.buttonAliases);
            } else if ((0, _tools.includes)(aliasName, Object.keys(this.stickAliases))) {
                this.stickAliases = (0, _tools.omit)([aliasName], this.stickAliases);
            } else {
                throw new Error('joymap.players.' + this.name + '.removeAlias(' + aliasName + ') couldn\'t find the alias \'' + aliasName + '\'');
            }
        }
    }, {
        key: 'cleanAliases',
        value: function cleanAliases() {
            this.buttonAliases = {};
            this.stickAliases = {};
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.disconnect();
            this.cleanInputs();
            this.cleanAliases();
            this.cleanAggregators();
        }
    }, {
        key: 'parseGamepad',
        value: function parseGamepad(gamepad /*: Gamepad*/) /*: IParsedGamepad*/ {
            var _this4 = this;

            var prevGamepad = this.parsedGamepad;

            return {
                buttons: gamepad.buttons.map(function (_ref5, index /*: number*/) {
                    var value = _ref5.value;

                    var previous /*: IButton*/ = prevGamepad.buttons[index];
                    var pressed = _this4.isButtonSignificant(value);

                    return {
                        pressed: pressed,
                        justChanged: pressed !== (previous ? _this4.isButtonSignificant(previous.value) : false),
                        value: value
                    };
                }),
                axes: gamepad.axes
            };
        }
    }, {
        key: 'update',
        value: function update(gamepad /*: Gamepad*/) {
            this.parsedGamepad = this.parseGamepad(gamepad);
            this.updateButtons(this.parsedGamepad);
            this.updateStick(this.parsedGamepad);
            this.updateAliases();
            this.updateAggregators(gamepad); // REVIEW: Shouldn't this use parsedGamepad too?

            this.listenOptions = (0, _utils.updateListenOptions)(this.listenOptions, this.parsedGamepad, this.threshold);
        }
    }, {
        key: 'getButtonValue',
        value: function getButtonValue() /*: IButtonValue*/ {
            var value /*: IButtonValue*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

            if (!this.clampThreshold) {
                return value;
            }

            return !this.isButtonSignificant(value) ? 0 : value;
        }
    }, {
        key: 'isButtonSignificant',
        value: function isButtonSignificant() /*: boolean*/ {
            var value /*: IButtonValue*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

            return Math.abs(value) > this.threshold;
        }
    }, {
        key: 'updateButtons',
        value: function updateButtons(gamepad /*: IParsedGamepad*/) {
            this.buttons = (0, _tools.mapValues)(function (binding /*: IButtonBinding*/) {
                return binding.mapper(gamepad);
            }, this.buttonBindings);
        }
    }, {
        key: 'getStickValue',
        value: function getStickValue(stickValues /*: IStickValue*/) /*: IStickValue*/ {
            if (this.clampThreshold && !this.isStickSignificant(stickValues)) {
                return stickValues.map(function () {
                    return 0;
                });
            }

            return stickValues;
        }
    }, {
        key: 'isStickSignificant',
        value: function isStickSignificant(stickValues /*: IStickValue*/) /*: boolean*/ {
            var _this5 = this;

            return stickValues.findIndex(function (value) {
                return Math.abs(value) >= _this5.threshold;
            }) !== -1;
        }
    }, {
        key: 'updateStick',
        value: function updateStick(gamepad /*: IParsedGamepad*/) {
            var _this6 = this;

            var prevStick = this.sticks;

            this.sticks = (0, _tools.mapValues)(function (binding /*: IStickBinding*/, inputName /*: string*/) {
                var previous /*: IStick*/ = prevStick[inputName];
                var value /*: IStickValue*/ = binding.mapper(gamepad, previous.inverts);
                var pressed = _this6.isStickSignificant(value);

                return {
                    pressed: pressed,
                    justChanged: pressed !== _this6.isStickSignificant(previous.value),
                    value: _this6.getStickValue(value),
                    inverts: previous.inverts
                };
            }, this.stickBindings);
        }
    }, {
        key: 'updateAliases',
        value: function updateAliases() {
            var _this7 = this;

            // When an alias has more than 1 button assigned to it, use for reference the one that's pressed the most
            this.buttonAliases = (0, _tools.mapValues)(function (alias /*: IButtonAlias*/) {
                var value = 0;

                alias.inputs.forEach(function (name) {
                    if (_this7.buttons[name].value > value) {
                        value = _this7.buttons[name].value;
                    }
                });

                value = _this7.getButtonValue(value);
                var pressed = _this7.isButtonSignificant(value);

                return {
                    pressed: pressed,
                    justChanged: pressed !== _this7.isButtonSignificant(alias.value),
                    value: value,
                    inputs: alias.inputs
                };
            }, this.buttonAliases);

            // When an alias has more than 1 stick assigned to it, do an average
            this.stickAliases = (0, _tools.mapValues)(function (alias /*: IStickAlias*/) {
                var counts = [];
                var count = 0;

                alias.inputs.forEach(function (name) {
                    if (_this7.sticks[name].pressed) {
                        counts = _this7.sticks[name].value.map(function (v, i) {
                            return v + (counts[i] || 0);
                        });
                        count += 1;
                    }
                });

                var value = count === 0 ? _this7.sticks[alias.inputs[0]].value.map(function () {
                    return 0;
                }) : counts.map(function (v) {
                    return v / count;
                });
                var pressed = _this7.isStickSignificant(value);

                return {
                    pressed: pressed,
                    justChanged: pressed !== _this7.isStickSignificant(alias.value),
                    value: value,
                    inputs: alias.inputs
                };
            }, this.stickAliases);
        }
    }, {
        key: 'updateAggregators',
        value: function updateAggregators(gamepad /*: Gamepad*/) {
            var _this8 = this;

            this.aggregators = (0, _tools.mapValues)(function (_ref6) {
                var callback = _ref6.callback,
                    value = _ref6.value;
                return {
                    callback: callback,
                    value: callback(_this8, value, gamepad)
                };
            }, this.aggregators);
        }
    }]);

    return Player;
}();

exports.default = Player;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @flow */


var _utils = __webpack_require__(0);

var _tools = __webpack_require__(1);

var _Player = __webpack_require__(2);

var _Player2 = _interopRequireDefault(_Player);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*:: type IParams = {
    threshold: number,
    clampThreshold: boolean,
    onPoll: () => void,
    playerHandling: 'manual' | 'auto'
};*/

var JoyMap = function () {
    function JoyMap() {
        var _this = this;

        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref$threshold = _ref.threshold,
            threshold = _ref$threshold === undefined ? 0.2 : _ref$threshold,
            _ref$clampThreshold = _ref.clampThreshold,
            clampThreshold = _ref$clampThreshold === undefined ? true : _ref$clampThreshold,
            _ref$onPoll = _ref.onPoll,
            onPoll = _ref$onPoll === undefined ? _tools.noop : _ref$onPoll,
            _ref$playerHandling = _ref.playerHandling,
            playerHandling = _ref$playerHandling === undefined ? 'auto' : _ref$playerHandling;

        _classCallCheck(this, JoyMap);

        this.animationFrameRequestId = null;
        this.isSupported = navigator && (0, _tools.isFunction)(navigator.getGamepads);
        this.gamepads = [];
        this.players = {};

        this.step = function () {
            _this.poll();
            _this.animationFrameRequestId = window.requestAnimationFrame(_this.step);
        };

        this.threshold = threshold;
        this.clampThreshold = clampThreshold;
        this.onPoll = onPoll;
        this.playerHandling = playerHandling;

        this.poll();
    }

    _createClass(JoyMap, [{
        key: 'start',
        value: function start() {
            if (this.isSupported && this.animationFrameRequestId === null) {
                this.animationFrameRequestId = window.requestAnimationFrame(this.step);
            }
        }
    }, {
        key: 'stop',
        value: function stop() {
            if (this.animationFrameRequestId !== null) {
                window.cancelAnimationFrame(this.animationFrameRequestId);
                this.animationFrameRequestId = null;
            }
        }
    }, {
        key: 'getUnusedGamepadIds',
        value: function getUnusedGamepadIds() /*: string[]*/ {
            return (0, _tools.difference)((0, _tools.map)('id', this.gamepads), (0, _tools.map)('gamepadId', this.players));
        }
    }, {
        key: 'setPlayers',
        value: function setPlayers() {
            var jsonString /*: string*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '{}';

            this.cleanPlayers();
            this.players = JSON.parse(jsonString);
        }
    }, {
        key: 'addPlayer',
        value: function addPlayer(name /*: string*/) /*: Player*/ {
            var _this2 = this;

            var threshold = this.threshold,
                clampThreshold = this.clampThreshold;


            var player /*: Player*/ = new _Player2.default({ name: name, threshold: threshold, clampThreshold: clampThreshold });

            var gamepadIds /*: string[]*/ = (0, _tools.map)('id', this.gamepads);
            var unusedId /*: ?string*/ = gamepadIds.find(function (gamepadId /*: string*/) {
                return !(0, _tools.findKey)({ gamepadId: gamepadId }, _this2.players);
            });

            if (unusedId) {
                player.connect(unusedId);
            }

            this.players[name] = player;

            return player;
        }
    }, {
        key: 'removePlayer',
        value: function removePlayer(player /*: Player*/) {
            this.players = (0, _tools.omit)([player.name], this.players);
            player.destroy();
        }
    }, {
        key: 'cleanPlayers',
        value: function cleanPlayers() {
            var _this3 = this;

            // REVIEW: Had to use "any" type because flow thinks Object.values return mixed
            // and fails to notice that this.players is { [key: string]: Player }
            Object.values(this.players).forEach(function (player /*: any*/) {
                return _this3.removePlayer(player);
            });
        }
    }, {
        key: 'poll',
        value: function poll() {
            var _this4 = this;

            this.gamepads = (0, _utils.getRawGamepads)().filter(function (rawGamepad /*: ?Gamepad*/) {
                return rawGamepad && rawGamepad.connected && rawGamepad.buttons.length && rawGamepad.axes.length && (!!rawGamepad.id || rawGamepad.id === 0);
            });

            Object.keys(this.players).forEach(function (name /*: string*/) {
                var player /*: Player*/ = _this4.players[name];
                var unusedGamepadIds = _this4.getUnusedGamepadIds();

                // Given unassigned players and unusued gamepads, automatically assign them
                if (_this4.playerHandling === 'auto' && player.gamepadId === null && unusedGamepadIds.length > 0) {
                    player.connect(unusedGamepadIds[0]);
                }

                var gamepad /*: ?Gamepad*/ = (0, _tools.find)({ id: player.gamepadId }, _this4.gamepads);

                if (!player.connected) {
                    if (gamepad) {
                        player.reconnect();
                        player.update(gamepad);
                    }
                } else if (gamepad) {
                    player.update(gamepad);
                } else {
                    player.disconnect();
                }
            });

            this.onPoll();
        }
    }]);

    return JoyMap;
}();

exports.default = JoyMap;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stickBindings = exports.makeButtonBinding = exports.Player = undefined;

var _JoyMap = __webpack_require__(3);

var _JoyMap2 = _interopRequireDefault(_JoyMap);

var _Player = __webpack_require__(2);

var _Player2 = _interopRequireDefault(_Player);

var _utils = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _JoyMap2.default; /* @flow */

// Ugly imports and export because flow does not understand export X from 'path'

var Player = exports.Player = _Player2.default;
var makeButtonBinding = exports.makeButtonBinding = _utils.makeButtonBinding;
var stickBindings = exports.stickBindings = _utils.stickBindings;

/***/ }
/******/ ]);
});