/* @flow */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("joymap", [], factory);
	else if(typeof exports === 'object')
		exports["joymap"] = factory();
	else
		root["joymap"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.l = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };

/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};

/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};

/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sticksMap = exports.stickIndexMapping = exports.buttonsMap = exports.buttonIndexMapping = undefined;
exports.makeButtonMapper = makeButtonMapper;
exports.addButtonAlias = addButtonAlias;
exports.makeStickMapper = makeStickMapper;
exports.addStickAlias = addStickAlias;
exports.getRawGamepads = getRawGamepads;

var _tools = __webpack_require__(1);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/* @flow */
/*:: import type {
    IStickAlias, IButtonAlias,
    IStickBinding, IButtonBinding
} from '../types';*/
var buttonIndexMapping = exports.buttonIndexMapping = {
    dpadUp: 12,
    dpadDown: 13,
    dpadLeft: 14,
    dpadRight: 15,
    L1: 4,
    L2: 6,
    L3: 10,
    R1: 5,
    R2: 7,
    R3: 11,
    A: 0,
    B: 1,
    X: 2,
    Y: 3,
    start: 9,
    select: 8
};

var mockButtons = {
    home: {
        index: -1,
        mapper: function mapper() {
            return 0;
        }
    }
};

function makeButtonMapper(index /*: number*/) /*: IButtonBinding*/ {
    return {
        index: index,
        mapper: function mapper(pad) {
            return pad.buttons[index];
        }
    };
}

var buttonsMap /*: { [key: string]: IButtonBinding }*/ = exports.buttonsMap = Object.assign((0, _tools.mapValues)(function (value) {
    return makeButtonMapper(value);
}, buttonIndexMapping), mockButtons);

function addButtonAlias(alias /*: ?IButtonAlias*/, inputs /*: string[]*/) {
    if (!alias) {
        return {
            inputs: inputs,
            value: 0,
            pressed: false,
            justChanged: false
        };
    }

    return Object.assign({}, alias, {
        inputs: [].concat(_toConsumableArray(alias.inputs), _toConsumableArray(inputs))
    });
}

var stickIndexMapping = exports.stickIndexMapping = {
    L: 0,
    R: 2
};

function makeStickMapper(index /*: number*/) /*: IStickBinding*/ {
    return {
        index: index,
        mapper: function mapper(pad) {
            var invertX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var invertY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            return {
                x: !invertX ? pad.axes[index] : -1 * pad.axes[index],
                y: !invertY ? pad.axes[index + 1] : -1 * pad.axes[index + 1]
            };
        }
    };
}
var sticksMap /*: { [key: string]: IStickBinding }*/ = exports.sticksMap = (0, _tools.mapValues)(function (value) {
    return makeStickMapper(value);
}, stickIndexMapping);

function addStickAlias(alias /*: ?IStickAlias*/, inputs /*: string[]*/) {
    if (!alias) {
        return {
            inputs: inputs,
            value: { x: 0, y: 0 },
            pressed: false,
            justChanged: false
        };
    }

    return Object.assign({}, alias, {
        inputs: [].concat(_toConsumableArray(alias.inputs), _toConsumableArray(inputs))
    });
}

function getRawGamepads() /*: Gamepad[]*/ {
    if (navigator && navigator.getGamepads) {
        return Array.from(navigator.getGamepads());
    }
    return [];
}

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.noop = noop;
exports.map = map;
exports.isFunction = isFunction;
exports.includes = includes;
exports.difference = difference;
exports.omit = omit;
exports.mapValues = mapValues;
exports.matches = matches;
exports.find = find;
exports.findIndex = findIndex;
exports.findKey = findKey;
// Lodash function replacements

/*:: type IteratorCb = (value: any, name: string) => boolean;*/
function noop() {}

function map() /*: any[]*/ {
    var attr /*: string*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var target /*: Object[] | Object*/ = arguments[1];

    if (Array.isArray(target)) {
        return target.map(function (value) {
            return value[attr];
        });
    }

    var indexes = Object.keys(target);
    var length = indexes.length;
    var result = [];
    var i = 0;
    while (i < length) {
        var index = indexes[i];
        result.push(target[index][attr]);
        i += 1;
    }

    return result;
}

function isFunction(value /*: any*/) /*: boolean*/ {
    return typeof value === 'function';
}

function includes /*:: <T>*/(search /*: T*/) /*: boolean*/ {
    var list /*: T[]*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    return list.indexOf(search) !== -1;
}

function difference /*:: <T>*/(source /*: T[]*/, removal /*: T[]*/) /*: T[]*/ {
    var length = source.length;
    var result = [];
    var i = 0;

    while (i < length) {
        if (!includes(source[i], removal)) {
            result.push(source[i]);
        }
        i += 1;
    }

    return result;
}

function omit(indexes /*: string[]*/, target /*: Object*/) /*: Object*/ {
    var length = indexes.length;
    var result = Object.assign({}, target);
    var i = 0;

    while (i < length) {
        delete result[indexes[i]];
        i += 1;
    }

    return result;
}

/*:: type MapValuesCb = (value: any, name: string) => any;*/
function mapValues(iterator /*: MapValuesCb*/, obj /*: Object*/) /*: Object*/ {
    var result = {};
    Object.keys(obj).forEach(function (name) {
        result[name] = iterator(obj[name], name);
    });
    return result;
}

function matches(comparison /*: Object*/, source /*: Object*/) {
    var match = Object.keys(comparison).map(function (name) {
        return [comparison[name], name];
    });
    var length = match.length;
    var i = 0;

    while (i < length) {
        var _match$i = _slicedToArray(match[i], 2),
            _value = _match$i[0],
            index = _match$i[1];

        if (source[index] !== _value) {
            return false;
        }
        i += 1;
    }

    return true;
}

function find(search /*: Object*/, target /*: any[]*/) /*: any | null*/ {
    var length = target.length;
    var i = 0;

    while (i < length) {
        var _value2 = target[i];
        if (matches(search, _value2)) {
            return _value2;
        }
        i += 1;
    }

    return null;
}

function findIndex(search /*: Object*/, target /*: any[]*/) /*: number*/ {
    var length = target.length;
    var i = 0;

    while (i < length) {
        if (matches(search, target[i])) {
            return i;
        }
        i += 1;
    }

    return -1;
}

function findKey(search /*: IteratorCb | Object*/, target /*: Object*/) /*: string | null*/ {
    var targetIndexes = Object.keys(target);
    var length = targetIndexes.length;
    var i = 0;
    if (typeof search === 'function') {
        while (i < length) {
            var index = targetIndexes[i];
            if (search(target[index], index)) {
                return index;
            }
            i += 1;
        }
    } else {
        while (i < length) {
            var _index = targetIndexes[i];
            if (matches(search, target[_index])) {
                return _index;
            }
            i += 1;
        }
    }

    return null;
}

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @flow */


var _utils = __webpack_require__(0);

var _tools = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*:: import type {
    IPoint, IParsedGamepad, IStick, IButton,
    IStickAlias, IButtonAlias, IAggregator,
    IStickBinding, IButtonBinding
} from './types';*/
/*:: type IParams = { name: string, threshold: number, clampThreshold: boolean };*/

var Player = function () {
    function Player() {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            name = _ref.name,
            _ref$threshold = _ref.threshold,
            threshold = _ref$threshold === undefined ? 0.3 : _ref$threshold,
            _ref$clampThreshold = _ref.clampThreshold,
            clampThreshold = _ref$clampThreshold === undefined ? true : _ref$clampThreshold;

        _classCallCheck(this, Player);

        this.parsedGamepad = {
            buttons: [],
            axes: []
        };
        this.buttonBindings = _utils.buttonsMap;
        this.stickBindings = _utils.sticksMap;
        this.listenOnPress = null;
        this.gamepadId = null;
        this.connected = false;
        this.buttonAliases = {};
        this.stickAliases = {};
        this.aggregators = {};

        this.name = name;
        this.threshold = threshold;
        this.clampThreshold = clampThreshold;

        this.cleanInputs();
    }

    _createClass(Player, [{
        key: 'cleanInputs',
        value: function cleanInputs() {
            this.buttonBindings = _utils.buttonsMap;
            this.stickBindings = _utils.sticksMap;

            this.buttons = (0, _tools.mapValues)(function () {
                return {
                    value: 0,
                    pressed: false,
                    justChanged: false
                };
            }, this.buttonBindings);

            this.sticks = (0, _tools.mapValues)(function () {
                return {
                    value: { x: 0, y: 0 },
                    pressed: false,
                    justChanged: false,
                    invertX: false,
                    invertY: false
                };
            }, this.stickBindings);
        }
    }, {
        key: 'disconnect',
        value: function disconnect() {
            this.connected = false;
        }
    }, {
        key: 'reconnect',
        value: function reconnect() {
            this.connected = true;
        }
    }, {
        key: 'connect',
        value: function connect(gamepadId /*: string*/) {
            this.connected = true;
            this.gamepadId = gamepadId;
        }
    }, {
        key: 'clearButtonBindings',
        value: function clearButtonBindings() {
            this.buttonBindings = {};
        }
    }, {
        key: 'clearStickBindings',
        value: function clearStickBindings() {
            this.stickBindings = {};
        }
    }, {
        key: 'buttonRebind',
        value: function buttonRebind(inputName /*: string*/, binding /*: IButtonBinding*/) {
            this.buttonBindings[inputName] = binding;
        }
    }, {
        key: 'stickRebind',
        value: function stickRebind(inputName /*: string*/, binding /*: IStickBinding*/) {
            this.stickBindings[inputName] = binding;
        }
    }, {
        key: 'cancelButtonRebindOnPress',
        value: function cancelButtonRebindOnPress() {
            this.listenOnPress = null;
        }
    }, {
        key: 'buttonRebindOnPress',
        value: function buttonRebindOnPress(inputName /*: string*/) {
            var _this = this;

            var callback /*: Function*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _tools.noop;
            var allowDuplication /*: boolean*/ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

            this.listenOnPress = function (index) {
                var bindingIndex = (0, _tools.findKey)({ index: index }, _this.buttonBindings);

                if (bindingIndex) {
                    if (inputName !== bindingIndex) {
                        if (allowDuplication) {
                            _this.buttonBindings[inputName] = (0, _utils.makeButtonMapper)(index);
                        } else {
                            var binding = _this.buttonBindings[bindingIndex];
                            _this.buttonBindings[bindingIndex] = _this.buttonBindings[inputName];
                            _this.buttonBindings[inputName] = binding;
                        }
                    }
                } else {
                    _this.buttonBindings[inputName] = (0, _utils.makeButtonMapper)(index);
                }

                callback(bindingIndex);
            };
        }
    }, {
        key: 'setAggregator',
        value: function setAggregator(aggregatorName /*: string*/, callback /*: Function*/) {
            this.aggregators[aggregatorName] = { callback: callback, value: null };
        }
    }, {
        key: 'removeAggregator',
        value: function removeAggregator(aggregatorName /*: string*/) {
            this.aggregators = (0, _tools.omit)([aggregatorName], this.aggregators);
        }
    }, {
        key: 'cleanAggregators',
        value: function cleanAggregators() {
            this.aggregators = {};
        }
    }, {
        key: 'setAlias',
        value: function setAlias(aliasName /*: string*/, inputs /*: string | string[]*/) {
            var inputList /*: string[]*/ = void 0;

            if (typeof inputs === 'string') {
                inputList = [inputs];
            } else {
                inputList = inputs;
            }

            if ((0, _tools.difference)(inputList, Object.keys(this.buttons)).length === 0) {
                this.buttonAliases[aliasName] = (0, _utils.addButtonAlias)(this.buttonAliases[aliasName], inputList);
            } else if ((0, _tools.difference)(inputList, Object.keys(this.sticks)).length === 0) {
                this.stickAliases[aliasName] = (0, _utils.addStickAlias)(this.stickAliases[aliasName], inputList);
            } else {
                throw new Error('joymap.players.' + this.name + '.setAlias(' + aliasName + ',\n                couldn\'t every single input (\'' + inputList.join(', ') + '\') in buttons or sticks exclusively');
            }
        }
    }, {
        key: 'removeAlias',
        value: function removeAlias(aliasName /*: string*/) {
            if ((0, _tools.includes)(aliasName, Object.keys(this.buttonAliases))) {
                this.buttonAliases = (0, _tools.omit)([aliasName], this.buttonAliases);
            } else if ((0, _tools.includes)(aliasName, Object.keys(this.stickAliases))) {
                this.stickAliases = (0, _tools.omit)([aliasName], this.stickAliases);
            } else {
                throw new Error('joymap.players.' + this.name + '.removeAlias(' + aliasName + ') couldn\'t find the alias \'' + aliasName + '\'');
            }
        }
    }, {
        key: 'cleanAliases',
        value: function cleanAliases() {
            this.buttonAliases = {};
            this.stickAliases = {};
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.disconnect();
            this.cleanInputs();
            this.cleanAliases();
            this.cleanAggregators();
        }
    }, {
        key: 'parseGamepad',
        value: function parseGamepad(gamepad /*: Gamepad*/) /*: IParsedGamepad*/ {
            var _this2 = this;

            var prevGamepad = this.parsedGamepad;

            return {
                buttons: gamepad.buttons.map(function (_ref2, index /*: number*/) {
                    var value = _ref2.value;

                    var previous /*: IButton*/ = prevGamepad.buttons[index];
                    var pressed = _this2.isButtonSignificant(value);

                    return {
                        pressed: pressed,
                        justChanged: pressed !== (previous ? _this2.isButtonSignificant(previous.value) : false),
                        value: value
                    };
                }),
                axes: gamepad.axes
            };
        }
    }, {
        key: 'update',
        value: function update(gamepad /*: Gamepad*/) {
            this.parsedGamepad = this.parseGamepad(gamepad);
            this.updateButtons(this.parsedGamepad);
            this.updateStick(this.parsedGamepad);
            this.updateAliases();
            this.updateAggregators(gamepad);

            var callback = this.listenOnPress;
            if (callback) {
                var index = this.parsedGamepad.buttons.findIndex(function (_ref3) {
                    var pressed = _ref3.pressed,
                        justChanged = _ref3.justChanged;
                    return pressed && justChanged;
                });

                if (index !== -1) {
                    callback(index);
                    this.listenOnPress = null;
                }
            }
        }
    }, {
        key: 'getButtonValue',
        value: function getButtonValue() /*: number*/ {
            var value /*: number*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

            if (!this.clampThreshold) {
                return value;
            }

            return Math.abs(value) < this.threshold ? 0 : value;
        }
    }, {
        key: 'isButtonSignificant',
        value: function isButtonSignificant() /*: boolean*/ {
            var value /*: number*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

            return !!value && Math.abs(value) > this.threshold;
        }
    }, {
        key: 'updateButtons',
        value: function updateButtons(gamepad /*: IParsedGamepad*/) {
            this.buttons = (0, _tools.mapValues)(function (binding /*: IButtonBinding*/) {
                return binding.mapper(gamepad);
            }, this.buttonBindings);
        }
    }, {
        key: 'getStickValue',
        value: function getStickValue() /*: IPoint*/ {
            var sticks /*: IPoint*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { x: 0, y: 0 };

            if (this.clampThreshold && Math.abs(sticks.x) < this.threshold && Math.abs(sticks.y) < this.threshold) {
                return { x: 0, y: 0 };
            }
            return sticks;
        }
    }, {
        key: 'isStickSignificant',
        value: function isStickSignificant() /*: boolean*/ {
            var sticks /*: IPoint*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { x: 0, y: 0 };

            return !!sticks && (!!sticks.x || !!sticks.y) && (Math.abs(sticks.x) > this.threshold || Math.abs(sticks.y) > this.threshold);
        }
    }, {
        key: 'updateStick',
        value: function updateStick(gamepad /*: IParsedGamepad*/) {
            var _this3 = this;

            var prevStick = this.sticks;

            this.sticks = (0, _tools.mapValues)(function (binding /*: IStickBinding*/, inputName /*: string*/) {
                var previous /*: IStick*/ = prevStick[inputName];
                var invertX = previous.invertX,
                    invertY = previous.invertY;

                var value /*: IPoint*/ = binding.mapper(gamepad, invertX, invertY);
                var pressed = _this3.isStickSignificant(value);

                return {
                    pressed: pressed,
                    justChanged: pressed !== _this3.isStickSignificant(previous.value),
                    value: _this3.getStickValue(value),
                    invertX: invertX,
                    invertY: invertY
                };
            }, this.stickBindings);
        }
    }, {
        key: 'updateAliases',
        value: function updateAliases() {
            var _this4 = this;

            // When an alias has more than 1 button assigned to it, use for reference the one that's pressed the most
            this.buttonAliases = (0, _tools.mapValues)(function (alias /*: IButtonAlias*/) {
                var value = 0;

                alias.inputs.forEach(function (name) {
                    if (_this4.buttons[name].value > value) {
                        value = _this4.buttons[name].value;
                    }
                });

                value = _this4.getButtonValue(value);
                var pressed = _this4.isButtonSignificant(value);

                return {
                    pressed: pressed,
                    justChanged: pressed !== _this4.isButtonSignificant(alias.value),
                    value: value,
                    inputs: alias.inputs
                };
            }, this.buttonAliases);

            // When an alias has more than 1 stick assigned to it, do an average
            this.stickAliases = (0, _tools.mapValues)(function (alias /*: IStickAlias*/) {
                var xCount = 0;
                var yCount = 0;
                var count = 0;

                alias.inputs.forEach(function (name) {
                    if (_this4.sticks[name].pressed) {
                        var _sticks$name$value = _this4.sticks[name].value,
                            x = _sticks$name$value.x,
                            y = _sticks$name$value.y;

                        xCount += x;
                        yCount += y;
                        count += 1;
                    }
                });

                var value = _this4.getStickValue({
                    x: count === 0 ? 0 : xCount / count,
                    y: count === 0 ? 0 : yCount / count
                });
                var pressed = _this4.isStickSignificant(value);

                return {
                    pressed: pressed,
                    justChanged: pressed !== _this4.isStickSignificant(alias.value),
                    value: value,
                    inputs: alias.inputs
                };
            }, this.stickAliases);
        }
    }, {
        key: 'updateAggregators',
        value: function updateAggregators(gamepad /*: Gamepad*/) {
            var _this5 = this;

            this.aggregators = (0, _tools.mapValues)(function (_ref4) {
                var callback = _ref4.callback,
                    value = _ref4.value;
                return {
                    callback: callback,
                    value: callback(_this5, value, gamepad)
                };
            }, this.aggregators);
        }
    }]);

    return Player;
}();

exports.default = Player;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* @flow */


var _utils = __webpack_require__(0);

var _tools = __webpack_require__(1);

var _Player = __webpack_require__(2);

var _Player2 = _interopRequireDefault(_Player);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*:: type IParams = { threshold: number, clampThreshold: boolean, onPoll: () => void };*/

var JoyMap = function () {
    function JoyMap() {
        var _this = this;

        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref$threshold = _ref.threshold,
            threshold = _ref$threshold === undefined ? 0.2 : _ref$threshold,
            _ref$clampThreshold = _ref.clampThreshold,
            clampThreshold = _ref$clampThreshold === undefined ? true : _ref$clampThreshold,
            _ref$onPoll = _ref.onPoll,
            onPoll = _ref$onPoll === undefined ? _tools.noop : _ref$onPoll;

        _classCallCheck(this, JoyMap);

        this.animationFrameRequestId = null;
        this.isSupported = navigator && (0, _tools.isFunction)(navigator.getGamepads);
        this.gamepads = [];
        this.players = {};

        this.step = function () {
            _this.poll();
            _this.animationFrameRequestId = window.requestAnimationFrame(_this.step);
        };

        this.threshold = threshold;
        this.clampThreshold = clampThreshold;
        this.onPoll = onPoll;

        this.poll();
    }

    _createClass(JoyMap, [{
        key: 'start',
        value: function start() {
            if (this.isSupported && this.animationFrameRequestId === null) {
                this.animationFrameRequestId = window.requestAnimationFrame(this.step);
            }
        }
    }, {
        key: 'stop',
        value: function stop() {
            if (this.animationFrameRequestId !== null) {
                window.cancelAnimationFrame(this.animationFrameRequestId);
                this.animationFrameRequestId = null;
            }
        }
    }, {
        key: 'getUnusedGamepadIds',
        value: function getUnusedGamepadIds() /*: string[]*/ {
            return (0, _tools.difference)((0, _tools.map)('id', this.gamepads), (0, _tools.map)('gamepadId', this.players));
        }
    }, {
        key: 'setPlayers',
        value: function setPlayers() {
            var jsonString /*: string*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '{}';

            this.cleanPlayers();
            this.players = JSON.parse(jsonString);
        }
    }, {
        key: 'addPlayer',
        value: function addPlayer(name /*: string*/) /*: Player*/ {
            var _this2 = this;

            var threshold = this.threshold,
                clampThreshold = this.clampThreshold;


            var player /*: Player*/ = new _Player2.default({ name: name, threshold: threshold, clampThreshold: clampThreshold });

            var gamepadIds /*: string[]*/ = (0, _tools.map)('id', this.gamepads);
            var unusedId /*: ?string*/ = gamepadIds.find(function (gamepadId /*: string*/) {
                return !(0, _tools.findKey)({ gamepadId: gamepadId }, _this2.players);
            });

            if (unusedId) {
                player.connect(unusedId);
            }

            this.players[name] = player;

            return player;
        }
    }, {
        key: 'removePlayer',
        value: function removePlayer(name /*: string*/) {
            var player /*: Player*/ = this.players[name];
            this.players = (0, _tools.omit)([name], this.players);
            player.destroy();
        }
    }, {
        key: 'cleanPlayers',
        value: function cleanPlayers() {
            var _this3 = this;

            Object.keys(this.players).forEach(function (name) {
                return _this3.removePlayer(name);
            });
        }
    }, {
        key: 'poll',
        value: function poll() {
            var _this4 = this;

            this.onPoll();

            this.gamepads = (0, _utils.getRawGamepads)().filter(function (rawGamepad /*: ?Gamepad*/) {
                return rawGamepad && rawGamepad.connected && rawGamepad.buttons.length && rawGamepad.axes.length && (!!rawGamepad.id || rawGamepad.id === 0);
            });

            Object.keys(this.players).forEach(function (name /*: string*/) {
                var player /*: Player*/ = _this4.players[name];
                var unusedGamepadIds = _this4.getUnusedGamepadIds();

                // Given unassigned players and unusued gamepads, automatically assign them
                if (player.gamepadId === null && unusedGamepadIds.length > 0) {
                    player.connect(unusedGamepadIds[0]);
                }

                var gamepad /*: ?Gamepad*/ = (0, _tools.find)({ id: player.gamepadId }, _this4.gamepads);

                if (!player.connected) {
                    if (gamepad) {
                        player.reconnect();
                        player.update(gamepad);
                    }
                } else if (gamepad) {
                    player.update(gamepad);
                } else {
                    player.disconnect();
                }
            });
        }
    }]);

    return JoyMap;
}();

exports.default = JoyMap;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeStickMapper = exports.makeButtonMapper = exports.Player = undefined;

var _JoyMap = __webpack_require__(3);

var _JoyMap2 = _interopRequireDefault(_JoyMap);

var _Player = __webpack_require__(2);

var _Player2 = _interopRequireDefault(_Player);

var _utils = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _JoyMap2.default; /* @flow */

// Ugly imports and export because flow does not understand export X from 'path'

var Player = exports.Player = _Player2.default;
var makeButtonMapper = exports.makeButtonMapper = _utils.makeButtonMapper;
var makeStickMapper = exports.makeStickMapper = _utils.makeStickMapper;

/***/ }
/******/ ]);
});